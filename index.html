<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>High-Vision: ADMIN EDITION</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a0a; font-family: 'Courier New', monospace; }
        canvas { display: block; background: #000; }
        
        /* THE ADMIN CONTROL PANEL */
        #admin-panel {
            position: absolute; top: 10px; left: 10px; width: 240px;
            background: rgba(0, 20, 20, 0.9); border: 2px solid #00ffcc;
            color: #00ffcc; padding: 15px; z-index: 1000; border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.5);
        }
        .admin-btn {
            width: 100%; padding: 10px; margin: 5px 0;
            background: #111; color: #00ffcc; border: 1px solid #00ffcc;
            cursor: pointer; font-weight: bold; text-transform: uppercase;
        }
        .admin-btn:hover { background: #00ffcc; color: #000; }
        .freeze-active { background: #ff0044 !important; color: white !important; border-color: white !important; }
    </style>
</head>
<body>

<div id="admin-panel">
    <h3 style="margin:0 0 10px 0; text-align:center;">SYSTEM ADMIN</h3>
    <button class="admin-btn" onclick="toggleGodMode()">God Mode: <span id="god-status">OFF</span></button>
    <button id="freeze-btn" class="admin-btn" onclick="toggleFreeze()">Freeze Army: OFF</button>
    <button class="admin-btn" onclick="teleportEnd()">Teleport to End</button>
    <div style="margin-top:10px; font-size:11px;">
        <label>Player Speed:</label>
        <input type="range" min="500" max="3000" value="1500" style="width:100%" oninput="player.speed = this.value">
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// --- GLOBALS ---
let lastTime = 0;
let worldTimeScale = 1.0;
let isGodMode = false;
const WORLD_WIDTH = 2000;
const FLOOR_Y = canvas.height - 100;

const input = { left: false, right: false, up: false };

// --- INPUTS ---
window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') input.left = true;
    if (e.key === 'ArrowRight') input.right = true;
    if (e.key === 'ArrowUp') input.up = true;
});
window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft') input.left = false;
    if (e.key === 'ArrowRight') input.right = false;
    if (e.key === 'ArrowUp') input.up = false;
});

// --- CAMERA ---
const camera = {
    x: 0,
    follow(target) {
        let targetX = target.x - canvas.width / 2;
        this.x += (targetX - this.x) * 0.1;
        this.x = Math.max(0, Math.min(this.x, WORLD_WIDTH - canvas.width));
    }
};

// --- PLAYER ---
class Player {
    constructor() {
        this.x = 100; this.y = FLOOR_Y - 40;
        this.width = 40; this.height = 40;
        this.velocityX = 0; this.velocityY = 0;
        this.speed = 1500; this.gravity = 1500; this.jump = -700;
        this.grounded = false;
    }
    update(dt) {
        if (input.left) this.velocityX -= this.speed * dt;
        if (input.right) this.velocityX += this.speed * dt;
        this.velocityX *= 0.85; 

        this.velocityY += this.gravity * dt;
        if (input.up && this.grounded) { this.velocityY = this.jump; this.grounded = false; }

        this.x += this.velocityX * dt;
        this.y += this.velocityY * dt;

        if (this.y + this.height > FLOOR_Y) {
            this.y = FLOOR_Y - this.height;
            this.velocityY = 0;
            this.grounded = true;
        }
    }
    draw() {
        ctx.fillStyle = isGodMode ? '#ff00ff' : '#00ffcc';
        if (isGodMode) { ctx.shadowBlur = 20; ctx.shadowColor = '#ff00ff'; }
        ctx.fillRect(this.x - camera.x, this.y, this.width, this.height);
        ctx.shadowBlur = 0;
    }
}

// --- ENEMY ---
class Enemy {
    constructor(x) {
        this.x = x; this.y = FLOOR_Y - 40;
        this.width = 40; this.height = 40;
    }
    update(dt) {
        // Only moves if worldTimeScale > 0
        this.x -= 150 * dt; 
        if (this.x < 0) this.x = WORLD_WIDTH;
    }
    draw() {
        ctx.fillStyle = '#ff4444';
        ctx.fillRect(this.x - camera.x, this.y, this.width, this.height);
    }
}

const player = new Player();
const enemies = [new Enemy(800), new Enemy(1200), new Enemy(1800)];

// --- ADMIN LOGIC ---
function toggleGodMode() {
    isGodMode = !isGodMode;
    document.getElementById('god-status').innerText = isGodMode ? "ON" : "OFF";
}

function toggleFreeze() {
    const btn = document.getElementById('freeze-btn');
    if (worldTimeScale > 0) {
        worldTimeScale = 0;
        btn.innerText = "Freeze Army: ACTIVE";
        btn.classList.add('freeze-active');
    } else {
        worldTimeScale = 1.0;
        btn.innerText = "Freeze Army: OFF";
        btn.classList.remove('freeze-active');
    }
}

function teleportEnd() {
    player.x = WORLD_WIDTH - 200;
}

// --- MAIN LOOP ---
function gameLoop(timestamp) {
    const dt = Math.min((timestamp - lastTime) / 1000, 0.1) || 0;
    lastTime = timestamp;

    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Update
    player.update(dt);
    camera.follow(player);
    
    enemies.forEach(en => {
        en.update(dt * worldTimeScale); // Enemies freeze when timescale is 0
        
        // Collision
        if (!isGodMode && player.x < en.x + en.width && player.x + player.width > en.x &&
            player.y < en.y + en.height && player.y + player.height > en.y) {
            player.x = 100; // Reset player on hit
        }
    });

    // Draw Floor
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(0 - camera.x, FLOOR_Y);
    ctx.lineTo(WORLD_WIDTH - camera.x, FLOOR_Y);
    ctx.stroke();

    // Draw Entities
    enemies.forEach(en => en.draw());
    player.draw();

    requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
