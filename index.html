<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pro-Tech Game</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { border: 2px solid #333; box-shadow: 0 0 20px rgba(0,0,0,0.5); background: #000; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script src="game.js"></script>
</body>
</html>const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Set professional resolution (16:9)
canvas.width = 800;
canvas.height = 450;

const input = { left: false, right: false, up: false };

// Handle Inputs
window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') input.left = true;
    if (e.key === 'ArrowRight') input.right = true;
});
window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft') input.left = false;
    if (e.key === 'ArrowRight') input.right = false;
});

class Player {
    constructor() {
        this.x = 50;
        this.y = 350;
        this.width = 40;
        this.height = 40;
        this.speed = 300; // Pixels per second
    }

    update(dt) {
        if (input.left) this.x -= this.speed * dt;
        if (input.right) this.x += this.speed * dt;
    }

    draw(ctx) {
        ctx.fillStyle = '#00ffcc';
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
}

const player = new Player();
let lastTime = 0;

function gameLoop(timestamp) {
    // Calculate Delta Time (seconds since last frame)
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    // 1. Clear Screen
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 2. Update Logic
    player.update(dt);

    // 3. Render
    player.draw(ctx);

    requestAnimationFrame(gameLoop);
}
class Player {
    constructor() {
        this.x = 100;
        this.y = 300;
        this.width = 40;
        this.height = 40;
        
        // Movement Properties
        this.velocityX = 0;
        this.velocityY = 0;
        this.speed = 1500;    // Acceleration force
        this.friction = 0.85;  // Sliding stop
        this.gravity = 1200;   // Downward pull
        this.jumpForce = -600; // Instant upward burst
        
        this.grounded = false;
    }

    update(dt) {
        // 1. Horizontal Movement (with friction)
        if (input.left) this.velocityX -= this.speed * dt;
        if (input.right) this.velocityX += this.speed * dt;
        this.velocityX *= this.friction; 

        // 2. Vertical Movement (Gravity)
        this.velocityY += this.gravity * dt;

        // 3. Jump Logic
        if (input.up && this.grounded) {
            this.velocityY = this.jumpForce;
            this.grounded = false;
        }

        // 4. Apply Velocity to Position
        this.x += this.velocityX * dt;
        this.y += this.velocityY * dt;

        // 5. Professional Floor Collision (Simple)
        const floorY = canvas.height - 50;
        if (this.y + this.height > floorY) {
            this.y = floorY - this.height;
            this.velocityY = 0;
            this.grounded = true;
        }
    }

    draw(ctx) {
        // Body
        ctx.fillStyle = '#00ffcc';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#00ffcc';
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Cleanup shadow for next draw calls
        ctx.shadowBlur = 0;
    }
}class Particle {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 4 + 2;
        this.speedX = (Math.random() - 0.5) * 200;
        this.speedY = (Math.random() - 0.5) * 200;
        this.life = 1.0; // 100% health
        this.decay = Math.random() * 2 + 1; 
    }

    update(dt) {
        this.x += this.speedX * dt;
        this.y += this.speedY * dt;
        this.life -= this.decay * dt;
    }

    draw(ctx) {
        ctx.fillStyle = `rgba(0, 255, 204, ${this.life})`;
        ctx.fillRect(this.x, this.y, this.size, this.size);
    }
}const entities = [];
const particles = [];

function createParticles(x, y) {
    for (let i = 0; i < 10; i++) {
        particles.push(new Particle(x, y));
    }
}

function gameLoop(timestamp) {
    const dt = Math.min((timestamp - lastTime) / 1000, 0.1); // Cap dt to prevent "teleporting"
    lastTime = timestamp;

    ctx.fillStyle = '#0a0a0a'; // Darker background for professional look
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 1. Draw Floor Line
    ctx.strokeStyle = '#333';
    ctx.beginPath();
    ctx.moveTo(0, canvas.height - 50);
    ctx.lineTo(canvas.width, canvas.height - 50);
    ctx.stroke();

    // 2. Update & Draw Player
    player.update(dt);
    player.draw(ctx);

    // 3. Handle Particles (Professional Polish)
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update(dt);
        particles[i].draw(ctx);
        if (particles[i].life <= 0) particles.splice(i, 1);
    }

    requestAnimationFrame(gameLoop);
}// --- CAMERA SYSTEM ---
const camera = {
    x: 0,
    y: 0,
    width: canvas.width,
    height: canvas.height,
    follow(target) {
        // Smoothly center the camera on the target (Lerp)
        let targetX = target.x - this.width / 2;
        this.x += (targetX - this.x) * 0.1; 
        
        // Clamp camera so it doesn't show out-of-bounds (assuming 2000px wide world)
        this.x = Math.max(0, Math.min(this.x, 2000 - this.width));
    }
};

// --- ENEMY AI CLASS ---
class Enemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 40;
        this.height = 40;
        this.velocityX = 0;
        this.speed = 100;
        this.state = 'PATROL'; // PATROL or CHASE
    }

    update(dt, player) {
        const dist = Math.abs(player.x - this.x);

        // State Logic
        if (dist < 250) {
            this.state = 'CHASE';
        } else {
            this.state = 'PATROL';
        }

        // Behavior Logic
        if (this.state === 'CHASE') {
            let direction = player.x > this.x ? 1 : -1;
            this.velocityX = direction * this.speed * 1.5;
        } else {
            // Simple Patrol (swings back and forth)
            this.velocityX = Math.sin(Date.now() / 1000) * this.speed;
        }

        this.x += this.velocityX * dt;
    }

    draw(ctx, camX) {
        ctx.fillStyle = '#ff4444'; // Red for enemies
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'red';
        // Subtract camX to render correctly in world space
        ctx.fillRect(this.x - camX, this.y, this.width, this.height);
        ctx.shadowBlur = 0;
    }
}

// --- INITIALIZATION ---
const enemy = new Enemy(600, 360);

function gameLoop(timestamp) {
    const dt = (timestamp - lastTime) / 1000 || 0;
    lastTime = timestamp;

    // 1. Logic Updates
    player.update(dt);
    enemy.update(dt, player);
    camera.follow(player);

    // 2. Rendering
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Everything inside the "World" must be offset by camera.x
    player.draw(ctx, camera.x); // Modified Player.draw to take camX
    enemy.draw(ctx, camera.x);
    
    requestAnimationFrame(gameLoop);
}// --- WORLD CONFIGURATION ---
const WORLD_WIDTH = 1000;
const FLOOR_Y = canvas.height - 50;

class Game {
    constructor() {
        this.isGameOver = false;
        this.score = 0;
    }

    checkCollision(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
               rect1.x + rect1.width > rect2.x &&
               rect1.y < rect2.y + rect2.height &&
               rect1.y + rect1.height > rect2.y;
    }

    drawUI(ctx) {
        ctx.fillStyle = "white";
        ctx.font = "20px Arial";
        ctx.fillText(`Distance: ${Math.floor(player.x)}m`, 20, 30);
        
        if (this.isGameOver) {
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "red";
            ctx.textAlign = "center";
            ctx.fillText("GAME OVER - Press F5 to Restart", canvas.width/2, canvas.height/2);
        }
    }
}

const gameState = new Game();

// --- UPDATED PLAYER DRAW (With Camera Offset) ---
// We add 'camX' so the player stays relative to the world
Player.prototype.draw = function(ctx, camX) {
    ctx.fillStyle = '#00ffcc';
    ctx.shadowBlur = 15;
    ctx.shadowColor = '#00ffcc';
    // Position on screen = World Position - Camera Position
    ctx.fillRect(this.x - camX, this.y, this.width, this.height);
    ctx.shadowBlur = 0;
};

// --- ENHANCED GAME LOOP ---
function gameLoop(timestamp) {
    const dt = (timestamp - lastTime) / 1000 || 0;
    lastTime = timestamp;

    if (!gameState.isGameOver) {
        // 1. Logic
        player.update(dt);
        enemy.update(dt, player);
        camera.follow(player);

        // 2. Collision Detection
        if (gameState.checkCollision(player, enemy)) {
            gameState.isGameOver = true;
        }
    }

    // 3. Rendering
    ctx.fillStyle = '#111'; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw the 1000px Floor
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(0 - camera.x, FLOOR_Y);
    ctx.lineTo(WORLD_WIDTH - camera.x, FLOOR_Y);
    ctx.stroke();

    // Draw Entities
    player.draw(ctx, camera.x);
    enemy.draw(ctx, camera.x);
    
    // Draw UI
    gameState.drawUI(ctx);

    requestAnimationFrame(gameLoop);
}

// In the Player's update method, I'm adding a "Land" effect:
// if (this.y + this.height > floorY && !this.grounded) {
//    createParticles(this.x + this.width/2, floorY);
// }
requestAnimationFrame(gameLoop);
